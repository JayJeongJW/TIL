# 📝 TIL - 2025.04.14 (내일배움캠프 C# 문법 종합반 1주차)

## 📝 배운 내용 및 개념

### 구조체 vs 클래스
- 구조체는 값형이고, 클래스는 참조형.
- 구조체는 작은 데이터를 저장하는 데 유리하고, 클래스는 상속, 다형성 등을 지원하여 복잡한 시스템에서 유리함.

### 필드와 메서드
- 필드는 객체의 상태를 나타내는 변수이고, 메서드는 객체가 수행할 작업을 정의한 함수.

### 생성자와 소멸자
- 생성자는 객체가 생성될 때 호출되어 객체의 초기화 작업을 수행하고,
- 소멸자는 객체가 메모리에서 제거될 때 호출되어 자원 해제를 담당함.

### 프로퍼티
- 데이터를 안전하게 접근하고 수정할 수 있는 특수한 메서드로, Getter와 Setter를 사용하여 필드를 간접적으로 다룸.

### 가상 메서드
- 부모 클래스에서 정의된 메서드를 자식 클래스에서 재정의할 수 있게 해주는 메서드.

### 추상 클래스와 메서드
- 추상 클래스는 인스턴스를 생성할 수 없으며, 추상 메서드는 자식 클래스에서 반드시 구현해야 하는 메서드.

### 오버라이딩과 오버로딩
- 오버라이딩은 부모 메서드를 자식 클래스에서 재정의하고,
- 오버로딩은 같은 메서드 이름을 사용하여 매개변수로 구분된 여러 메서드를 정의.

### 제너릭
- 다양한 데이터 타입을 처리할 수 있게 해주는 기법으로, 코드의 재사용성과 타입 안정성을 높일 수 있음.

### out, ref 키워드
- ref는 이미 초기화된 변수를 함수에 전달할 때 사용하고, out은 함수에서 값을 반환할 때 사용함.

### 인터페이스
- 클래스가 구현해야 할 메서드 서명을 정의하는 계약으로, 여러 클래스가 동일한 인터페이스를 구현할 수 있도록 함.

### 열거형
- 관련된 상수들을 하나의 타입으로 묶어 관리할 수 있게 해주는 자료형.

### 예외 처리
- try-catch 구문을 사용해 프로그램에서 발생할 수 있는 예외를 처리하고, 프로그램이 비정상적으로 종료되지 않도록 함.

### finally 블록
- 예외가 발생하든 발생하지 않든 반드시 실행되어야 하는 코드를 작성하는 블록.

### 값형과 참조형
- 값형은 데이터를 직접 저장하고, 참조형은 메모리 주소를 저장하는 데이터 타입.

### 박싱과 언박싱
- 값형을 참조형으로 변환하는 박싱과, 참조형을 값형으로 변환하는 언박싱.

### 델리게이트, 람다, LINQ
- 델리게이트는 메서드를 참조할 수 있는 객체,
- 람다는 익명 메서드를 간결하게 작성하는 방법,
- LINQ는 데이터를 쿼리하는 기법으로 데이터를 필터링하고 변환하는 데 유용함.

### func, Action
- func는 값을 반환하는 메서드에, Action은 값을 반환하지 않는 메서드에 사용되는 델리게이트.

### Nullable
- 값형 변수에 null 값을 할당할 수 있도록 하는 기능으로, 값형도 null을 가질 수 있게 됨.

### 문자열 빌더
- 문자열을 효율적으로 다루기 위한 클래스로, 문자열을 여러 번 결합할 때 성능을 최적화함.

---

## ❗ 문제점

### 오버라이딩과 오버로딩의 차이점
- 두 개념의 사용 목적을 헷갈려함.
- 오버라이딩은 부모 메서드를 자식 클래스에서 재정의하는 것,
- 오버로딩은 메서드 이름을 동일하게 두고 매개변수로 구분하여 정의하는 것.

### ref와 out 키워드
- ref는 초기화된 변수를 함수로 전달해야 하고,
- out은 초기화하지 않고 값만 반환받을 수 있다는 점에서 차이가 있음을 명확히 이해하기 어려웠음.

### 프로퍼티의 사용법
- 필드와 프로퍼티의 차이를 처음에 잘못 이해했음.
- 필드는 직접 접근이 가능하지만, 프로퍼티는 getter와 setter를 사용해 간접적으로 값을 다룬다는 점을 계속 보다 보니 조금 알게됨.

### 제너릭을 사용할 때 타입 미지정 오류
- 제너릭을 사용할 때 타입을 명시하지 않아서 오류가 발생함.
- 제너릭을 사용할 때는 반드시 타입을 명확하게 지정해야 함을 깨달음.

### 추상 클래스와 메서드의 활용법
- 추상 클래스는 인스턴스를 생성할 수 없다는 점과 추상 메서드는 자식 클래스에서 반드시 구현해야 한다는 점을 제대로 이해하는 데 시간이 걸림.

### 인터페이스 메서드 구현 시 서명 일치 오류
- 인터페이스를 구현할 때 메서드 서명이 정확히 일치해야 한다는 점을 처음에는 제대로 이해하지 못했음.

### 값형과 참조형의 차이
- 값형과 참조형이 메모리에서 다르게 처리된다는 점을 제대로 알지 못해 변수를 전달할 때 실수가 발생했음.

### 박싱과 언박싱 오류
- 박싱과 언박싱을 할 때 타입을 잘못 맞춰서 오류가 발생한 적이 있음. 이를 정확히 처리하는 방법을 처음에는 잘 몰랐음.

---

## 💡 시도해본 것

### 오버라이딩과 오버로딩 예제 작성
- 두 개념을 명확히 구분하기 위해 각각의 예제를 작성.
- 오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의하고,
- 오버로딩은 같은 이름의 메서드를 매개변수로 구분하여 여러 가지 메서드를 정의.

### ref와 out 키워드 활용
- ref와 out을 사용하여 값을 함수에 전달하고, 함수 내에서 값을 변경하거나 할당하는 방법을 시도.
- ref는 초기값이 필요하고, out은 함수에서 반환할 값을 할당해야 한다는 점을 확실히 이해.

### 프로퍼티 활용
- 필드와 프로퍼티의 차이를 이해하고, 프로퍼티를 사용하여 데이터를 안전하게 다루는 방법을 실습.
- get과 set을 통해 값을 간접적으로 수정하는 방식을 익힘.

### 제너릭 사용법 연습
- 제너릭 타입을 정확하게 지정하여, 다양한 타입을 안전하게 처리할 수 있도록 연습.
- 예를 들어 `List<T>`에서 T를 정수와 문자열로 바꾸어 사용해 봄.

### 추상 클래스와 메서드
- 추상 클래스를 활용하여 다형성을 구현하고, 자식 클래스에서 추상 메서드를 오버라이딩하여 실제 구현체를 제공.

### 인터페이스 구현 연습
- 인터페이스를 구현하여 여러 클래스에서 동일한 메서드 서명을 사용하도록 해 봄. 이를 통해 다형성을 효율적으로 구현.

### 값형과 참조형의 차이 이해
- 값형과 참조형을 사용할 때 메모리에서 어떻게 다르게 처리되는지 실습을 통해 이해.

### 박싱과 언박싱 처리
- 박싱과 언박싱을 올바르게 처리하여, 값형과 참조형 간의 타입 변환을 안전하게 수행.

---

## 🧠 알게 된 것

### 오버라이딩과 오버로딩
- 오버라이딩은 부모 메서드를 자식에서 재정의하고, 오버로딩은 같은 이름을 가진 여러 메서드를 매개변수로 구분하는 방법으로 차이를 이해함.

### ref와 out 키워드의 차이점
- ref는 변수에 값을 전달하면서 그 값을 수정하고, out은 함수에서 반환할 값을 전달하며,
- 함수 내에서 값을 초기화해야 한다는 점을 명확히 이해.

### 프로퍼티 활용
- 프로퍼티를 사용하여 데이터를 직접 접근하지 않고,
- 안전하게 getter와 setter를 통해 값을 수정하는 방법을 배우고, 코드의 안전성을 높일 수 있다는 점을 알게 됨.

### 제너릭의 장점
- 제너릭을 사용하면 타입을 명시할 수 있어 코드의 재사용성을 높이고,
- 타입 안전성을 보장할 수 있다는 점을 실습을 통해 확실히 이해.

### 추상 클래스와 메서드
- 추상 클래스는 인스턴스를 만들 수 없고, 자식 클래스에서 추상 메서드를 구현해야 한다는 점을 이해하고,
- 다형성을 효과적으로 구현할 수 있다는 점을 알게 됨.

### 인터페이스의 역할
- 인터페이스는 클래스가 구현해야 할 메서드 서명을 정의하여,
- 클래스 간의 계약을 형성하고 다형성을 효율적으로 사용할 수 있도록 한다는 점을 배움.

### 값형과 참조형의 차이
- 값형과 참조형이 메모리에서 다르게 처리되어, 함수에 전달될 때 어떻게 다르게 동작하는지 정확히 알게 됨.

### 박싱과 언박싱
- 박싱과 언박싱은 타입 변환 시 발생할 수 있는 문제를 이해하고, 이를 안전하게 처리할 수 있는 방법을 배우게 됨.
